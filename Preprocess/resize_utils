import pydicom as dicom 
import cv2 as cv
import numpy as np
import cv2
import png


def image_as_png(image, png_filename, bitdepth=16):
    
    with open(png_filename, 'wb') as f:
        writer = png.Writer(
            height=image.shape[0],
            width=image.shape[1],
            bitdepth=bitdepth,
            greyscale=True
        )
        writer.write(f, image.tolist())


def segment_breast(img, low_int_threshold=.05, crop=True):

        # Create img for thresholding and contours.
        img_8u = (img.astype('float32')/img.max()*255).astype('uint8')
        if low_int_threshold < 1.:
            low_th = int(img_8u.max()*low_int_threshold)
        else:
            low_th = int(low_int_threshold)
        _, img_bin = cv2.threshold(
            img_8u, low_th, maxval=255, type=cv2.THRESH_BINARY)
        ver = (cv2.__version__).split('.')
        if int(ver[0]) < 3:
            contours,_ = cv2.findContours(
                img_bin.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        else:
            contours,_ = cv2.findContours(
                img_bin.copy(), cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        cont_areas = [ cv2.contourArea(cont) for cont in contours ]
        idx = np.argmax(cont_areas)  # find the largest contour, i.e. breast.
        breast_mask = cv2.drawContours(
            np.zeros_like(img_bin), contours, idx, 255, -1)  # fill the contour.
        # segment the breast.
        img_breast_only = cv2.bitwise_and(img, img, mask=breast_mask)
        x,y,w,h = cv2.boundingRect(contours[idx])
        if crop:
            img_breast_only = img_breast_only[y:y+h, x:x+w]
            
        return img_breast_only


def resize_image(image_path,Height_new, Width_new):

    # Read the DICOM image
    image = dicom.dcmread(image_path).pixel_array
    
    print(f'Original image shape: {image.shape}')

    original_ratio = image.shape[1] / image.shape[0]
    
    new_ratio = Width_new / Height_new
    

    # Resized based on the height (needs width padding)
    if new_ratio > original_ratio:
        scaling_factor = Height_new / image.shape[0]
        new_size = (int(image.shape[1] * scaling_factor), Height_new)


    # Resized based on the width (needs height padding)
    elif new_ratio < original_ratio:
        scaling_factor = Width_new / image.shape[1]
        new_size = (Width_new, int(image.shape[0] * scaling_factor))
    

    resized_image = cv.resize(image, new_size, interpolation=cv.INTER_LINEAR)

    # initial padding parameters
    top_pad = 0
    bottom_pad = 0
    left_pad = 0
    right_pad = 0

    # height padding (pad the image to the desired height)
    if resized_image.shape[0] < Height_new:
        pad_height = Height_new - resized_image.shape[0]
        print(f'Pad width: {pad_height}')
        # Half of the pad on each side
        top_pad = pad_height // 2
        bottom_pad = pad_height - top_pad
        print(f'Top pad: {top_pad}, Bottom pad: {bottom_pad}')
        # Apply the padding
        resized_image = cv.copyMakeBorder(resized_image, top_pad, bottom_pad, 0, 0, cv.BORDER_CONSTANT, value=0)
        print(f'Padded image shape: {resized_image.shape}')
        
    # width padding (pad the image to the desired width)
    elif resized_image.shape[1] < Width_new:
        pad_width = Width_new - resized_image.shape[1]
        print(f'Pad width: {pad_width}')
        # Half of the pad on each side
        left_pad = pad_width // 2
        right_pad = pad_width - left_pad
        print(f'Left pad: {left_pad}, Right pad: {right_pad}')
        # Apply the padding
        resized_image = cv.copyMakeBorder(resized_image, 0, 0, left_pad, right_pad, cv.BORDER_CONSTANT, value=0)
        print(f'Padded image shape: {resized_image.shape}')
        
    else:
        # Image is already in the desired aspect ratio
        print('Image is already in the desired aspect ratio.')
        resized_image = cv.resize(image, (Width_new, Height_new), interpolation=cv.INTER_LINEAR)
        print(f'Resized image shape: {resized_image.shape}')
        
    # raise an error if the resized image is not in in the desired shape 
    if resized_image.shape[0] != Height_new or resized_image.shape[1] != Width_new:
        raise ValueError(f'Resized image shape {resized_image.shape} does not match the desired shape ({Height_new}, {Width_new})')
        
        
    return resized_image, scaling_factor, top_pad, bottom_pad, left_pad, right_pad
